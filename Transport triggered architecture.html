<html>
<head>
 <title>Computer Architecture </title>
 </head>
<body background="https://previews.123rf.com/images/apostrophe/apostrophe1306/apostrophe130600009/20161882-abstract-pattern-background-white-gray-pinstripe-line-design-element-for-graphic-art-use-vertical-li.jpg">
    <table width="100%">
        <tr>
            <td> <a href="index.html"> Main </a> </td>
            <td> <a href="Computer Hardware.html"> Computer Hardware </a> </td>
            <td> <a href="all of CPU.html"> all of CPU </a> </td>
            <td> <a href="Software Architecture.html"> Software Architecture </a> </td>
            <td>Transport triggered architecture</td>
        </tr>
    </table>
    <br>
    <center> <font color="red" size="7"> Transport triggered architecture </font> </center>
    <font size="5">
        <ul>
            <font color="light blue" size="6"> Transport triggered architecture </font>
            <br>
            is a kind of processor design in which programs directly control the internal transport buses of a processor. Computation happens as a side effect of data transports: writing data into a triggering port of a functional unit triggers the functional unit to start a computation. This is similar to what happens in a systolic array. Due to its modular structure, TTA is an ideal processor template for application-specific instruction-set processors (ASIP) with customized datapath but without the inflexibility and design cost of fixed function hardware accelerators.

Typically a transport triggered processor has multiple transport buses and multiple functional units connected to the buses, which provides opportunities for instruction level parallelism. The parallelism is statically defined by the programmer. In this respect (and obviously due to the large instruction word width), the TTA architecture resembles the very long instruction word (VLIW) architecture. A TTA instruction word is composed of multiple slots, one slot per bus, and each slot determines the data transport that takes place on the corresponding bus. The fine-grained control allows some optimizations that are not possible in a conventional processor. For example, software can transfer data directly between functional units without using registers.

Transport triggering exposes some microarchitectural details that are normally hidden from programmers. This greatly simplifies the control logic of a processor, because many decisions normally done at run time are fixed at compile time. However, it also means that a binary compiled for one TTA processor will not run on another one without recompilation if there is even a small difference in the architecture between the two. The binary incompatibility problem, in addition to the complexity of implementing a full context switch, makes TTAs more suitable for embedded systems than for general purpose computing.

Of all the one instruction set computer architectures, the TTA architecture is one of the few that has had processors based on it built, and the only one that has processors based on it sold commercially.
            <br>
            <br>
            <font color="light blue" size="6"> Benefits in comparison to VLIW architectures </font>
            <br>
            TTAs can be seen as "exposed datapath" VLIW architectures. While VLIW is programmed using operations, TTA splits the operation execution to multiple move operations. The low level programming model enables several benefits in comparison to the standard VLIW. For example, a TTA architecture can provide more parallelism with simpler register files than with VLIW. As the programmer is in control of the timing of the operand and result data transports, the complexity (the number of input and output ports) of the register file (RF) need not be scaled according to the worst case issue/completion scenario of the multiple parallel instructions.
            <br>
            <br>
            <font color="light blue" size="6"> programming </font>
            In more traditional processor architectures, a processor is usually programmed by defining the executed operations and their operands. For example, an addition instruction in a RISC architecture could look like the following.

            add r3, r1, r2
This example operation adds the values of general-purpose registers r1 and r2 and stores the result in register r3. Coarsely, the execution of the instruction in the processor probably results in translating the instruction to control signals which control the interconnection network connections and function units. The interconnection network is used to transfer the current values of registers r1 and r2 to the function unit that is capable of executing the add operation, often called ALU as in Arithmetic-Logic Unit. Finally, a control signal selects and triggers the addition operation in ALU, of which result is transferred back to the register r3.

TTA programs do not define the operations, but only the data transports needed to write and read the operand values. Operation itself is triggered by writing data to a triggering operand of an operation. Thus, an operation is executed as a side effect of the triggering data transport. Therefore, executing an addition operation in TTA requires three data transport definitions, also called moves. A move defines endpoints for a data transport taking place in a transport bus. For instance, a move can state that a data transport from function unit F, port 1, to register file R, register index 2, should take place in bus B1. In case there are multiple buses in the target processor, each bus can be utilized in parallel in the same clock cycle. Thus, it is possible to exploit data transport level parallelism by scheduling several data transports in the same instruction.
            <br>
            <br>
        </ul>
    </font>
    <br>
    <center><img src="https://www.researchgate.net/profile/Vladimir-Guzma/publication/236676682/figure/fig13/AS:304217211326468@1449542443432/An-example-of-TTA-with-five-buses-and-reduced-connectivity-A-TTA-architecture-with.png"></center>
</body>
 </html>
